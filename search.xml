<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.基础算法</title>
      <link href="/2023/07/01/comment_trial/"/>
      <url>/2023/07/01/comment_trial/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-快速排序"><a href="#1-1-快速排序" class="headerlink" title="1.1 快速排序"></a>1.1 快速排序</h2><h3 id="思想：分治"><a href="#思想：分治" class="headerlink" title="思想：分治"></a>思想：分治</h3><p>(1)确定分界点(中点)<br>(2)调整区间($\leq x$的放在左边，$\geq x$的放在右边)<br>(3)递归处理左右两段</p><h3 id="暴力的方法"><a href="#暴力的方法" class="headerlink" title="暴力的方法"></a>暴力的方法</h3><p>扫描$q[l-r]$:把$\leq x$的存到$a[\ ]$, 把$\geq x$的存到$b[\ ]$<br>把$a[\ ]$,$b[\ ]$合并成$q[\ ]$</p><h3 id="优美的方法-双指针"><a href="#优美的方法-双指针" class="headerlink" title="优美的方法:双指针"></a>优美的方法:双指针</h3><p>两个指针一头一尾，如果左右两边都符合条件，那么往中间挪</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>(1)快速排序不是稳定的，因为相同的值的位置在经过排序后可能会改变。<br>(2)平均时间复杂度:$O(nlogn)$</p><hr><h2 id="1-2归并排序"><a href="#1-2归并排序" class="headerlink" title="1.2归并排序"></a>1.2归并排序</h2><h3 id="思想：分治-1"><a href="#思想：分治-1" class="headerlink" title="思想：分治"></a>思想：分治</h3><p>(1)确定分界点$mid &#x3D; (l + r) &#x2F; 2$<br>(2)递归排序左右两边<br>(3)归并：合二为一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">// 取中点</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid), <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r); <span class="comment">// 递归排序左右两边</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>; <span class="comment">// k用于对存到什么位置进行计数</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = q[j ++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对还没存完的元素继续存</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line">    <span class="comment">// 用tmp[]更新g[]</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h3><p>(1)归并排序是稳定的<br>(2)时间复杂度$O(nlogn)$</p><h3 id="应用：求逆序对的数量"><a href="#应用：求逆序对的数量" class="headerlink" title="应用：求逆序对的数量"></a>应用：求逆序对的数量</h3><p>给定一个长度为$n$的整数数列，请你计算数列中的逆序对的数量。<br>逆序对的定义如下：对于数列的第$i$个和第$j$个元素，如果满足$ i&lt;j $ 且 $a[i]&gt;a[j]$，则其为一个逆序对；否则不是。<br>注:一个长度为$n$的数组的最大逆序对数量是当其递减时，其值为$\displaystyle\sum_{i&#x3D;0}^{n-1} i &#x3D; \displaystyle\frac{n(n-1)}{2}$注意是否超过$int(10^9)$的范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> <span class="comment">// 该函数能在归并排序的同时输出逆序对的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 返回结果 = 中点左边的逆序对数量+中点右边的逆序对数量+起点在左边、终点在右边的逆序对数量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起点在左边、终点在右边的逆序对数量 = 归并排序中每次出现左边大于右边时左边与终点之间的数量之和</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k ++] = q[j ++];</span><br><span class="line">            res += (mid - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 扫尾</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++] = q[i ++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++] = q[j ++];</span><br><span class="line">    <span class="comment">// 物归原主</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3二分"><a href="#1-3二分" class="headerlink" title="1.3二分"></a>1.3二分</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
