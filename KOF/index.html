<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>拳皇</title>
    <script src="https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js"></script>
    <style>
        #kof {
            width: 1280px;
            height: 720px;

            background-image: url('https://pic.imgdb.cn/item/64afb9c11ddac507cc17f936.gif');
            background-size: 200% 100%;
            background-position: top;
            position: absolute;
        }

        #kof>.kof-head {
            width: 100%;
            height: 80px;
            position: absolute;
            top: 0;
            display: flex;
            align-items: center;
        }

        #kof>.kof-head>.kof-head-hp-0 {
            height: 40px;
            width: calc(50% - 60px);
            border: white 5px solid;
            border-right: none;
            margin-left: 20px;
            box-sizing: border-box;
        }

        #kof>.kof-head>.kof-head-timer {
            height: 60px;
            width: 80px;
            background-color: orange;
            border: white 5px solid;
            box-sizing: border-box;
            color: white;
            font-size: 30px;
            font-weight: 800;
            text-align: center;
            line-height: 50px;
            user-select: none;
        }

        #kof>.kof-head>.kof-head-hp-1 {
            height: 40px;
            width: calc(50% - 60px);

            border: white 5px solid;
            border-left: none;
            margin-right: 5px;
            box-sizing: border-box;
        }

        #kof>.kof-head>.kof-head-hp-0>div {
            background-color: red;
            width: 100%;
            height: 100%;
            float: right;
        }

        #kof>.kof-head>.kof-head-hp-1>div {
            background-color: red;
            width: 100%;
            height: 100%;
        }

        #kof>.kof-head>.kof-head-hp-0>div>div {
            background-color: lightgreen;
            width: 100%;
            height: 100%;
            float: right;
        }

        #kof>.kof-head>.kof-head-hp-1>div>div {
            background-color: lightgreen;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="kof"></div>

    <script type="module">
        // 基本游戏对象
        let AC_GAME_OBJECTS = []; // 全局数组储存所有游戏对象

        class AcGameObject {
            constructor() {
                AC_GAME_OBJECTS.push(this);
                this.timedelta = 0;
                this.has_call_start = false;
            }

            start() { // 初始执行一次

            }

            update() { // 每帧执行一次（除第一帧）

            }

            destroy() { //删除当前对象
                for (let i in AC_GAME_OBJECTS) {
                    if (AC_GAME_OBJECTS[i] === this) {
                        AC_GAME_OBJECTS.splice(i, 1);
                        break;
                    }
                }
            }
        }

        let last_timestamp; // 上一帧的执行时刻

        let AC_GAME_OBJECT_FRAME = (timestamp) => {
            // 让数组中的每个元素每帧更新
            // timestamp表示此时的执行时刻
            for (let obj of AC_GAME_OBJECTS) {
                if (!obj.has_call_start) {
                    obj.start();
                    obj.has_call_start = true;
                } else {
                    obj.timedelta = timestamp - last_timestamp;
                    obj.update();
                }
            }

            last_timestamp = timestamp;
            // 递归执行requestAnimationFrame
            requestAnimationFrame(AC_GAME_OBJECT_FRAME);
        }
        // 启动
        requestAnimationFrame(AC_GAME_OBJECT_FRAME);
        // 基本游戏对象

        // 控制器
        class Controller {
            constructor($canvas) {
                this.$canvas = $canvas;
                // Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用
                this.pressed_keys = new Set();
                this.start();
            }

            start() {
                let outer = this;
                this.$canvas.keydown((e) => {
                    outer.pressed_keys.add(e.key); // e.key表示按了哪个键
                    // console.log(e.key);
                });
                this.$canvas.keyup((e) => {
                    outer.pressed_keys.delete(e.key);
                });
            }
        }
        // 控制器

        // 第三方包
        const GIF = function () {
            // 第三方包，用于处理gif
            // **NOT** for commercial use.
            var timerID;                          // timer handle for set time out usage
            var st;                               // holds the stream object when loading.
            var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing.
            var interlaceSteps = [8, 8, 4, 2];
            var interlacedBufSize;  // this holds a buffer to de interlace. Created on the first frame and when size changed
            var deinterlaceBuf;
            var pixelBufSize;    // this holds a buffer for pixels. Created on the first frame and when size changed
            var pixelBuf;
            const GIF_FILE = { // gif file data headers
                GCExt: 0xF9,
                COMMENT: 0xFE,
                APPExt: 0xFF,
                UNKNOWN: 0x01, // not sure what this is but need to skip it in parser
                IMAGE: 0x2C,
                EOF: 59,   // This is entered as decimal
                EXT: 0x21,
            };
            // simple buffered stream used to read from the file 
            var Stream = function (data) {
                this.data = new Uint8ClampedArray(data);
                this.pos = 0;
                var len = this.data.length;
                this.getString = function (count) { // returns a string from current pos of len count
                    var s = "";
                    while (count--) { s += String.fromCharCode(this.data[this.pos++]) }
                    return s;
                };
                this.readSubBlocks = function () { // reads a set of blocks as a string
                    var size, count, data = "";
                    do {
                        count = size = this.data[this.pos++];
                        while (count--) { data += String.fromCharCode(this.data[this.pos++]) }
                    } while (size !== 0 && this.pos < len);
                    return data;
                }
                this.readSubBlocksB = function () { // reads a set of blocks as binary
                    var size, count, data = [];
                    do {
                        count = size = this.data[this.pos++];
                        while (count--) { data.push(this.data[this.pos++]); }
                    } while (size !== 0 && this.pos < len);
                    return data;
                }
            };
            // LZW decoder uncompressed each frames pixels
            // this needs to be optimised.
            // minSize is the min dictionary as powers of two
            // size and data is the compressed pixels
            function lzwDecode(minSize, data) {
                var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len;
                pos = pixelPos = 0;
                dic = [];
                clear = 1 << minSize;
                eod = clear + 1;
                size = minSize + 1;
                done = false;
                while (!done) { // JavaScript optimisers like a clear exit though I never use 'done' apart from fooling the optimiser
                    last = code;
                    code = 0;
                    for (i = 0; i < size; i++) {
                        if (data[pos >> 3] & (1 << (pos & 7))) { code |= 1 << i }
                        pos++;
                    }
                    if (code === clear) { // clear and reset the dictionary
                        dic = [];
                        size = minSize + 1;
                        for (i = 0; i < clear; i++) { dic[i] = [i] }
                        dic[clear] = [];
                        dic[eod] = null;
                    } else {
                        if (code === eod) { done = true; return }
                        if (code >= dic.length) { dic.push(dic[last].concat(dic[last][0])) }
                        else if (last !== clear) { dic.push(dic[last].concat(dic[code][0])) }
                        d = dic[code];
                        len = d.length;
                        for (i = 0; i < len; i++) { pixelBuf[pixelPos++] = d[i] }
                        if (dic.length === (1 << size) && size < 12) { size++ }
                    }
                }
            };
            function parseColourTable(count) { // get a colour table of length count  Each entry is 3 bytes, for RGB.
                var colours = [];
                for (var i = 0; i < count; i++) { colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]]) }
                return colours;
            }
            function parse() {        // read the header. This is the starting point of the decode and async calls parseBlock
                var bitField;
                st.pos += 6;
                gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                bitField = st.data[st.pos++];
                gif.colorRes = (bitField & 0b1110000) >> 4;
                gif.globalColourCount = 1 << ((bitField & 0b111) + 1);
                gif.bgColourIndex = st.data[st.pos++];
                st.pos++;                    // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
                if (bitField & 0b10000000) { gif.globalColourTable = parseColourTable(gif.globalColourCount) } // global colour flag
                setTimeout(parseBlock, 0);
            }
            function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that
                st.pos += 1;
                if ('NETSCAPE' === st.getString(8)) { st.pos += 8 }  // ignoring this data. iterations (word) and terminator (byte)
                else {
                    st.pos += 3;            // 3 bytes of string usually "2.0" when identifier is NETSCAPE
                    st.readSubBlocks();     // unknown app extension
                }
            };
            function parseGCExt() { // get GC data
                var bitField;
                st.pos++;
                bitField = st.data[st.pos++];
                gif.disposalMethod = (bitField & 0b11100) >> 2;
                gif.transparencyGiven = bitField & 0b1 ? true : false; // ignoring bit two that is marked as  userInput???
                gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                gif.transparencyIndex = st.data[st.pos++];
                st.pos++;
            };
            function parseImg() {                           // decodes image data to create the indexed pixel image
                var deinterlace, frame, bitField;
                deinterlace = function (width) {                   // de interlace pixel data if needed
                    var lines, fromLine, pass, toline;
                    lines = pixelBufSize / width;
                    fromLine = 0;
                    if (interlacedBufSize !== pixelBufSize) {      // create the buffer if size changed or undefined.
                        deinterlaceBuf = new Uint8Array(pixelBufSize);
                        interlacedBufSize = pixelBufSize;
                    }
                    for (pass = 0; pass < 4; pass++) {
                        for (toLine = interlaceOffsets[pass]; toLine < lines; toLine += interlaceSteps[pass]) {
                            deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width);
                            fromLine += width;
                        }
                    }
                };
                frame = {}
                gif.frames.push(frame);
                frame.disposalMethod = gif.disposalMethod;
                frame.time = gif.length;
                frame.delay = gif.delayTime * 10;
                gif.length += frame.delay;
                if (gif.transparencyGiven) { frame.transparencyIndex = gif.transparencyIndex }
                else { frame.transparencyIndex = undefined }
                frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                bitField = st.data[st.pos++];
                frame.localColourTableFlag = bitField & 0b10000000 ? true : false;
                if (frame.localColourTableFlag) { frame.localColourTable = parseColourTable(1 << ((bitField & 0b111) + 1)) }
                if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous
                    pixelBuf = new Uint8Array(frame.width * frame.height);
                    pixelBufSize = frame.width * frame.height;
                }
                lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels
                if (bitField & 0b1000000) {                        // de interlace if needed
                    frame.interlaced = true;
                    deinterlace(frame.width);
                } else { frame.interlaced = false }
                processFrame(frame);                               // convert to canvas image
            };
            function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data.
                var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti;
                frame.image = document.createElement('canvas');
                frame.image.width = gif.width;
                frame.image.height = gif.height;
                frame.image.ctx = frame.image.getContext("2d");
                ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable;
                if (gif.lastFrame === null) { gif.lastFrame = frame }
                useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false;
                if (!useT) { frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height) }
                cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height);
                ti = frame.transparencyIndex;
                dat = cData.data;
                if (frame.interlaced) { pDat = deinterlaceBuf }
                else { pDat = pixelBuf }
                pixCount = pDat.length;
                ind = 0;
                for (i = 0; i < pixCount; i++) {
                    pixel = pDat[i];
                    col = ct[pixel];
                    if (ti !== pixel) {
                        dat[ind++] = col[0];
                        dat[ind++] = col[1];
                        dat[ind++] = col[2];
                        dat[ind++] = 255;      // Opaque.
                    } else
                        if (useT) {
                            dat[ind + 3] = 0; // Transparent.
                            ind += 4;
                        } else { ind += 4 }
                }
                frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos);
                gif.lastFrame = frame;
                if (!gif.waitTillDone && typeof gif.onload === "function") { doOnloadEvent() }// if !waitTillDone the call onload now after first frame is loaded
            };
            // **NOT** for commercial use.
            function finnished() { // called when the load has completed
                gif.loading = false;
                gif.frameCount = gif.frames.length;
                gif.lastFrame = null;
                st = undefined;
                gif.complete = true;
                gif.disposalMethod = undefined;
                gif.transparencyGiven = undefined;
                gif.delayTime = undefined;
                gif.transparencyIndex = undefined;
                gif.waitTillDone = undefined;
                pixelBuf = undefined; // dereference pixel buffer
                deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used);
                pixelBufSize = undefined;
                deinterlaceBuf = undefined;
                gif.currentFrame = 0;
                if (gif.frames.length > 0) { gif.image = gif.frames[0].image }
                doOnloadEvent();
                if (typeof gif.onloadall === "function") {
                    (gif.onloadall.bind(gif))({ type: 'loadall', path: [gif] });
                }
                if (gif.playOnLoad) { gif.play() }
            }
            function canceled() { // called if the load has been cancelled
                finnished();
                if (typeof gif.cancelCallback === "function") { (gif.cancelCallback.bind(gif))({ type: 'canceled', path: [gif] }) }
            }
            function parseExt() {              // parse extended blocks
                const blockID = st.data[st.pos++];
                if (blockID === GIF_FILE.GCExt) { parseGCExt() }
                else if (blockID === GIF_FILE.COMMENT) { gif.comment += st.readSubBlocks() }
                else if (blockID === GIF_FILE.APPExt) { parseAppExt() }
                else {
                    if (blockID === GIF_FILE.UNKNOWN) { st.pos += 13; } // skip unknow block
                    st.readSubBlocks();
                }

            }
            function parseBlock() { // parsing the blocks
                if (gif.cancel !== undefined && gif.cancel === true) { canceled(); return }

                const blockId = st.data[st.pos++];
                if (blockId === GIF_FILE.IMAGE) { // image block
                    parseImg();
                    if (gif.firstFrameOnly) { finnished(); return }
                } else if (blockId === GIF_FILE.EOF) { finnished(); return }
                else { parseExt() }
                if (typeof gif.onprogress === "function") {
                    gif.onprogress({ bytesRead: st.pos, totalBytes: st.data.length, frame: gif.frames.length });
                }
                setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in.
            };
            function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded
                if (gif.complete) { return false }
                gif.cancelCallback = callback;
                gif.cancel = true;
                return true;
            }
            function error(type) {
                if (typeof gif.onerror === "function") { (gif.onerror.bind(this))({ type: type, path: [this] }) }
                gif.onload = gif.onerror = undefined;
                gif.loading = false;
            }
            function doOnloadEvent() { // fire onload event if set
                gif.currentFrame = 0;
                gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now
                if (typeof gif.onload === "function") { (gif.onload.bind(gif))({ type: 'load', path: [gif] }) }
                gif.onerror = gif.onload = undefined;
            }
            function dataLoaded(data) { // Data loaded create stream and parse
                st = new Stream(data);
                parse();
            }
            function loadGif(filename) { // starts the load
                var ajax = new XMLHttpRequest();
                ajax.responseType = "arraybuffer";
                ajax.onload = function (e) {
                    if (e.target.status === 404) { error("File not found") }
                    else if (e.target.status >= 200 && e.target.status < 300) { dataLoaded(ajax.response) }
                    else { error("Loading error : " + e.target.status) }
                };
                ajax.open('GET', filename, true);
                ajax.send();
                ajax.onerror = function (e) { error("File error") };
                this.src = filename;
                this.loading = true;
            }
            function play() { // starts play if paused
                if (!gif.playing) {
                    gif.paused = false;
                    gif.playing = true;
                    playing();
                }
            }
            function pause() { // stops play
                gif.paused = true;
                gif.playing = false;
                clearTimeout(timerID);
            }
            function togglePlay() {
                if (gif.paused || !gif.playing) { gif.play() }
                else { gif.pause() }
            }
            function seekFrame(frame) { // seeks to frame number.
                clearTimeout(timerID);
                gif.currentFrame = frame % gif.frames.length;
                if (gif.playing) { playing() }
                else { gif.image = gif.frames[gif.currentFrame].image }
            }
            function seek(time) { // time in Seconds  // seek to frame that would be displayed at time
                clearTimeout(timerID);
                if (time < 0) { time = 0 }
                time *= 1000; // in ms
                time %= gif.length;
                var frame = 0;
                while (time > gif.frames[frame].time + gif.frames[frame].delay && frame < gif.frames.length) { frame += 1 }
                gif.currentFrame = frame;
                if (gif.playing) { playing() }
                else { gif.image = gif.frames[gif.currentFrame].image }
            }
            function playing() {
                var delay;
                var frame;
                if (gif.playSpeed === 0) {
                    gif.pause();
                    return;
                } else {
                    if (gif.playSpeed < 0) {
                        gif.currentFrame -= 1;
                        if (gif.currentFrame < 0) { gif.currentFrame = gif.frames.length - 1 }
                        frame = gif.currentFrame;
                        frame -= 1;
                        if (frame < 0) { frame = gif.frames.length - 1 }
                        delay = -gif.frames[frame].delay * 1 / gif.playSpeed;
                    } else {
                        gif.currentFrame += 1;
                        gif.currentFrame %= gif.frames.length;
                        delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed;
                    }
                    gif.image = gif.frames[gif.currentFrame].image;
                    timerID = setTimeout(playing, delay);
                }
            }
            var gif = {                      // the gif image object
                onload: null,       // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame
                onerror: null,       // fires on error
                onprogress: null,       // fires a load progress event
                onloadall: null,       // event fires when all frames have loaded and gif is ready
                paused: false,      // true if paused
                playing: false,      // true if playing
                waitTillDone: true,       // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded
                loading: false,      // true if still loading
                firstFrameOnly: false,      // if true only load the first frame
                width: null,       // width in pixels
                height: null,       // height in pixels
                frames: [],         // array of frames
                comment: "",         // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated
                length: 0,          // gif length in ms (1/1000 second)
                currentFrame: 0,          // current frame. 
                frameCount: 0,          // number of frames
                playSpeed: 1,          // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc...
                lastFrame: null,       // temp hold last frame loaded so you can display the gif as it loads
                image: null,       // the current image at the currentFrame
                playOnLoad: true,       // if true starts playback when loaded
                // functions
                load: loadGif,    // call this to load a file
                cancel: cancelLoad, // call to stop loading
                play: play,       // call to start play
                pause: pause,      // call to pause
                seek: seek,       // call to seek to time
                seekFrame: seekFrame,  // call to seek to frame
                togglePlay: togglePlay, // call to toggle play and pause state
            };
            return gif;
        }
        // 第三方包

        // Player
        class Player extends AcGameObject {
            constructor(root, info) {
                super();

                this.root = root;
                this.ctx = this.root.game_map.ctx;
                // (x, y) 坐标
                this.x = info.x;
                this.y = info.y;
                // 宽、高、颜色
                this.width = info.width;
                this.height = info.height;
                this.color = info.color;
                // id
                this.id = info.id;
                // 当前速度
                this.vx = 0;
                this.vy = 0;
                // 水平初速度
                this.speedx = 400;
                // 起跳初速度
                this.speedy = -1000;
                // 方向(正方向为1，反方向为-1)
                this.direction = 1;
                // 重力加速度
                this.gravity = 50;
                // 状态
                this.status = 0; // 0: idle, 1: 向前, 2: 向后, 3: 跳跃, 4: 攻击, 5: 被打, 6: 死亡
                // 按下键的集合
                this.pressed_keys = this.root.game_map.controller.pressed_keys;
                // 动画
                this.animations = new Map();
                // 当前记录了多少帧
                this.frame_current_cnt = 0;
                // 生命
                this.hp = 100;
                // 外层血条残影
                this.$hp_shadow = this.root.$kof.find(`.kof-head-hp-${this.id}>div`);
                // 里层血条
                this.$hp = this.$hp_shadow.find(`div`);

            }

            start() {
                // console.log('start');
            }

            update_control() {
                let w, a, d, space;
                if (this.id === 0) {
                    w = this.pressed_keys.has('w');
                    a = this.pressed_keys.has('a');
                    d = this.pressed_keys.has('d');
                    space = this.pressed_keys.has(' ');
                } else {
                    w = this.pressed_keys.has('ArrowUp');
                    a = this.pressed_keys.has('ArrowLeft');
                    d = this.pressed_keys.has('ArrowRight');
                    space = this.pressed_keys.has('Enter');
                }
                if (this.status === 0 || this.status === 1) {
                    if (space) {
                        this.status = 4;
                        this.vx = 0;
                        this.frame_current_cnt = 0; // 为了在进入攻击状态时从动画的第一帧开始播放
                    } else if (w) {
                        if (d) {
                            this.vx = this.speedx;
                            console.log(this.vx);
                        } else if (a) {
                            this.vx = -this.speedx;
                        } else {
                            this.vx = 0;
                        }

                        this.vy = this.speedy;
                        this.status = 3;
                    } else if (d) {
                        this.vx = this.speedx;
                        this.status = 1;
                    } else if (a) {
                        this.vx = -this.speedx;
                        this.status = 1;
                    } else {
                        this.vx = 0;
                        this.status = 0;
                    }
                }

            }

            update_move() {

                this.vy += this.gravity;

                this.x += this.vx * this.timedelta / 1000; // timedelta单位是ms
                this.y += this.vy * this.timedelta / 1000;

                if (this.y > 450) {
                    this.y = 450;
                    this.vy = 0;
                    if (this.status === 3)
                        this.status = 0;
                }

                if (this.x < 0) {
                    this.x = 0;
                } else if (this.x + this.width > this.root.game_map.$canvas.width()) {
                    this.x = this.root.game_map.$canvas.width() - this.width;
                }
                // console.log(this.vy, this.y);
            }

            update_direction() {
                if (this.status === 6) return;

                let players = this.root.players;
                if (players[0] && players[1]) {
                    let me = this, you = players[1 - this.id];
                    if (me.x < you.x) me.direction = 1;
                    else me.direction = -1;
                }
            }

            update_attack() {
                if (this.status === 4 && this.frame_current_cnt === 18) {
                    // 在攻击动作的第18帧进行碰撞检测
                    let me = this, you = this.root.players[1 - this.id];
                    let r1; // 我的坐标
                    if (this.direction > 0) {
                        r1 = {
                            // 左上角
                            x1: me.x + 120,
                            y1: me.y + 40,
                            // 右下角
                            x2: me.x + 120 + 100,
                            y2: me.y + 40 + 20,
                        };
                    } else {
                        r1 = {
                            // 左上角
                            x1: me.x + me.width - 120 - 100,
                            y1: me.y + 40,
                            // 右下角
                            x2: me.x + me.width - 120 - 100 + 100,
                            y2: me.y + 40 + 20,
                        }
                    };
                    let r2 = {
                        // 对方的坐标
                        // 左上角
                        x1: you.x,
                        y1: you.y,
                        // 右下角
                        x2: you.x + you.width,
                        y2: you.y + you.height,
                    };
                    if (this.is_collision(r1, r2)) {
                        you.is_attack();
                    }

                }
            }
            is_attack() {
                if (this.status === 6) return;
                this.status = 5;
                this.frame_current_cnt = 0;
                this.hp = Math.max(this.hp - 20, 0);
                this.$hp.animate({
                    // 渐变
                    width: this.$hp.parent().width() / 100 * this.hp
                }, 300)
                this.$hp_shadow.animate({
                    // 渐变
                    width: this.$hp.parent().width() / 100 * this.hp
                }, 800)
                if (this.hp <= 0) {
                    this.status = 6;
                    this.frame_current_cnt = 0;
                    this.vx = 0;
                }
            }

            is_collision(r1, r2) {
                // 碰撞检测函数
                // 水平
                if (Math.max(r1.x1, r2.x1) > Math.min(r1.x2, r2.x2))
                    return false;
                // 竖直
                if (Math.max(r1.y1, r2.y1) > Math.min(r1.y2, r2.y2))
                    return false;
                return true;
            }
            update() {
                // 加载不出来时不渲染
                let status = this.status;
                if (this.status === 1 && this.vx * this.direction < 0) status = 2;
                let obj = this.animations.get(status);
                if (obj.loaded == false) {
                    return;
                }


                this.update_control();
                this.update_move();
                this.update_direction();
                this.update_attack();
                this.render();

            }

            render() {
                // 渲染
                // // 碰撞盒子
                // // 角色方块dddd
                // this.ctx.fillStyle = this.color;
                // this.ctx.fillRect(this.x, this.y, this.width, this.height);
                // // 拳头方块
                // this.ctx.fillStyle = this.color;
                // if (this.direction > 0) {
                //     this.ctx.fillRect(this.x + 120, this.y + 40, 100, 20);
                // } else {
                //     this.ctx.fillRect(this.x + this.width - 120 - 100, this.y + 40, 100, 20);
                // }


                let status = this.status;
                if (this.status === 1 && this.vx * this.direction < 0) status = 2;
                let obj = this.animations.get(status);
                if (obj && obj.loaded) {

                    if (this.direction > 0) {
                        let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt;
                        let image = obj.gif.frames[k].image;
                        // canvas的画图函数
                        this.ctx.drawImage(image, this.x, this.y + obj.off_set_y, image.width * obj.scale, image.height * obj.scale);
                    } else {
                        // direction < 0 时翻转绘制
                        this.ctx.save(); // 保存
                        this.ctx.scale(-1, 1); // 坐标轴水平翻转
                        this.ctx.translate(-this.root.game_map.$canvas.width(), 0);
                        let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt;
                        let image = obj.gif.frames[k].image;
                        // canvas的画图函数
                        this.ctx.drawImage(image, this.root.game_map.$canvas.width() - this.width - this.x, this.y + obj.off_set_y, image.width * obj.scale, image.height * obj.scale);
                        this.ctx.restore(); //恢复现场
                    }




                }


                // 特判攻击动作停止
                if (status === 4 || status === 5 || status === 6) {
                    if (this.frame_current_cnt == obj.frame_rate * (obj.frame_cnt - 1)) {
                        if (status === 6) {
                            this.frame_current_cnt--;
                        } else {
                            this.status = 0;
                        }
                    }

                }
                this.frame_current_cnt++;
            }
        }
        // Player

        //Kyo
        class Kyo extends Player {
            constructor(root, info) {
                super(root, info);
                this.init_animations();
            }

            init_animations() {
                let outer = this;
                // 偏移量数组
                let offsets = [0, -22, -22, -140, 0, 0, 0];
                let gif_array = [
                    `https://pic.imgdb.cn/item/64afba5b1ddac507cc19eff2.gif`,
                    `https://pic.imgdb.cn/item/64afba691ddac507cc1a23b7.gif`,
                    `https://pic.imgdb.cn/item/64afba721ddac507cc1a4083.gif`,
                    `https://pic.imgdb.cn/item/64afba7f1ddac507cc1a6b49.gif`,
                    `https://pic.imgdb.cn/item/64afba891ddac507cc1a8e85.gif`,
                    `https://pic.imgdb.cn/item/64afba941ddac507cc1ab6fc.gif`,
                    `https://pic.imgdb.cn/item/64afba9e1ddac507cc1ad3cb.gif`,
                ];
                for (let i = 0; i < 7; i++) {
                    // 第三方包
                    let gif = GIF();
                    gif.load(gif_array[i]);
                    this.animations.set(i, {
                        gif: gif,
                        frame_cnt: 0, // 当前动画总帧数
                        frame_rate: 5, // 每秒刷帧的速率, 每5帧渲染下一张
                        off_set_y: offsets[i], // 竖直方向偏移量
                        loaded: false, // 有无被加载
                        scale: 2, // 放大多少倍
                    });

                    gif.onload = () => {
                        let obj = outer.animations.get(i);
                        // 第三方包的逻辑：gif的每一帧被提取出来存在gif.frames[]数组中
                        obj.frame_cnt = gif.frames.length;
                        obj.loaded = true;
                        if (i === 3) {
                            obj.frame_rate = 4;
                        }
                    }
                }
            }
        }
        //Kyo






        class GameMap extends AcGameObject {
            // 游戏地图继承自游戏对象
            constructor(root) {
                super();
                // root表示画的内容，是KOF类的实例
                this.root = root;
                // jQuery定义canvas，是一个数组
                // 属性tabindex=0使canvas能够聚焦(键盘的字符能够输入)
                this.$canvas = $('<canvas tabindex=0 width="1280" height="720"></canvas>');
                // ctx是一个canvas对象
                this.ctx = this.$canvas[0].getContext('2d');
                // 在原对象之后添加$canvas所代表的html
                this.root.$kof.append(this.$canvas);
                // 自动聚焦画布
                this.$canvas.focus();
                // 控制器读取键盘
                this.controller = new Controller(this.$canvas);
                //血条和计时器
                this.root.$kof.append($(`<div class="kof-head">
                <div class="kof-head-hp-0">
                    <div>
                        <div></div>
                    </div>
                </div>
                <div class="kof-head-timer">60</div>
                <div class="kof-head-hp-1">
                    <div>
                        <div></div>
                    </div>
                </div>
                </div>`));
                this.time_left = 60000; // 剩余时间(ms)
                this.$timer = this.root.$kof.find('.kof-head-timer');

            }
            start() {
                // console.log('start')
            }

            update() {
                // 更新时间
                this.time_left -= this.timedelta;
                if (this.time_left < 0) {
                    this.time_left = 0;
                    let [a, b] = this.root.players;
                    if (a.status !== 6 && b.status !== 6) {
                        a.status = b.status = 6;
                        a.frame_current_cnt = b.frame_current_cnt = 0;
                        a.vx = b.vx = 0;
                    }
                }
                this.$timer.text(parseInt(this.time_left / 1000));

                this.render();
            }

            render() {
                // 渲染，清空地图
                // 获取一个canvas对象的宽度可以用obj.canvas.width，高度同理
                // 也可以通过obj.$canvas.width()
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                // 渲染成黑色进行试验
                // this.ctx.fillStyle = 'black';
                // this.ctx.fillRect(0, 0, this.$canvas.width(), this.$canvas.height());
            }
        }

        class KOF {
            constructor(id) {
                // $kof是对象
                this.$kof = $('#' + id);
                // console.log(this.$kof);

                this.game_map = new GameMap(this);
                this.players = [
                    new Kyo(this, {
                        id: 0,
                        x: 200,
                        y: 0,
                        width: 120,
                        height: 200,
                        color: 'blue',
                    }),
                    new Kyo(this, {
                        id: 1,
                        x: 900,
                        y: 0,
                        width: 120,
                        height: 200,
                        color: 'red',
                    }),
                ];
            }
        }
        let kof = new KOF('kof');
    </script>
</body>

</html>